// Harmonic Beacon - Database Schema
// PostgreSQL 16 + Prisma ORM

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ===================
// ENUMS
// ===================

enum UserRole {
  LISTENER
  PROVIDER
  ADMIN
}

enum SessionType {
  LIVE
  MEDITATION
  SCHEDULED_SESSION
}

enum ScheduledSessionStatus {
  SCHEDULED
  LIVE
  ENDED
  CANCELLED
}

enum TagCategory {
  MOOD
  TECHNIQUE
  DURATION
  LANGUAGE
}

enum ModerationStatus {
  PENDING
  APPROVED
  REJECTED
}

// ===================
// USER
// ===================

model User {
  id            String    @id @default(uuid())
  zitadelId     String    @unique @map("zitadel_id")
  email         String    @unique
  name          String?
  avatarUrl     String?   @map("avatar_url")
  role          UserRole  @default(LISTENER)
  isVerified    Boolean   @default(false) @map("is_verified")
  
  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  
  // Relations
  meditations           Meditation[]           @relation("ProviderMeditations")
  sessions              ListeningSession[]
  favorites             Favorite[]
  scheduledSessions     ScheduledSession[]     @relation("ProviderScheduledSessions")
  sessionParticipations SessionParticipant[]

  @@map("users")
}

// ===================
// MEDITATION
// ===================

model Meditation {
  id              String            @id @default(uuid())
  title           String
  description     String?
  durationSeconds Int               @map("duration_seconds")
  
  // File storage
  filePath        String            @map("file_path")    // e.g., "amor.ogg"
  originalPath    String?           @map("original_path") // Original upload
  streamName      String            @unique @map("stream_name") // go2rtc stream ID
  
  // Provider
  providerId      String            @map("provider_id")
  provider        User              @relation("ProviderMeditations", fields: [providerId], references: [id])
  
  // Moderation
  status          ModerationStatus  @default(PENDING)
  rejectionReason String?           @map("rejection_reason")
  reviewedAt      DateTime?         @map("reviewed_at")
  
  // Visibility
  isPublished     Boolean           @default(false) @map("is_published")
  isFeatured      Boolean           @default(false) @map("is_featured")
  
  // Timestamps
  createdAt       DateTime          @default(now()) @map("created_at")
  updatedAt       DateTime          @updatedAt @map("updated_at")
  
  // Relations
  tags            MeditationTag[]
  sessions        ListeningSession[]
  favorites       Favorite[]
  
  @@map("meditations")
}

// ===================
// TAGS (Many-to-Many)
// ===================

model Tag {
  id          String        @id @default(uuid())
  name        String        @unique
  slug        String        @unique
  category    TagCategory
  sortOrder   Int           @default(0) @map("sort_order")
  
  // Relations
  meditations MeditationTag[]
  
  @@map("tags")
}

model MeditationTag {
  meditationId  String      @map("meditation_id")
  tagId         String      @map("tag_id")
  
  meditation    Meditation  @relation(fields: [meditationId], references: [id], onDelete: Cascade)
  tag           Tag         @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  @@id([meditationId, tagId])
  @@map("meditation_tags")
}

// ===================
// LISTENING SESSIONS
// ===================

model ListeningSession {
  id              String        @id @default(uuid())
  
  userId          String        @map("user_id")
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Nullable for live sessions
  meditationId    String?       @map("meditation_id")
  meditation      Meditation?   @relation(fields: [meditationId], references: [id], onDelete: SetNull)

  // Nullable for scheduled sessions
  scheduledSessionId String?           @map("scheduled_session_id")
  scheduledSession   ScheduledSession? @relation(fields: [scheduledSessionId], references: [id], onDelete: SetNull)

  type            SessionType
  durationSeconds Int           @map("duration_seconds")
  completed       Boolean       @default(false)
  
  // Timestamps
  startedAt       DateTime      @default(now()) @map("started_at")
  endedAt         DateTime?     @map("ended_at")
  
  @@index([userId, startedAt])
  @@index([meditationId])
  @@index([scheduledSessionId])
  @@map("listening_sessions")
}

// ===================
// FAVORITES
// ===================

model Favorite {
  userId        String      @map("user_id")
  meditationId  String      @map("meditation_id")

  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  meditation    Meditation  @relation(fields: [meditationId], references: [id], onDelete: Cascade)

  createdAt     DateTime    @default(now()) @map("created_at")

  @@id([userId, meditationId])
  @@map("favorites")
}

// ===================
// SCHEDULED SESSIONS
// ===================

model ScheduledSession {
  id              String                  @id @default(uuid())
  title           String
  description     String?
  roomName        String                  @unique @map("room_name")

  // Provider (host)
  providerId      String                  @map("provider_id")
  provider        User                    @relation("ProviderScheduledSessions", fields: [providerId], references: [id])

  // Scheduling
  scheduledAt     DateTime?               @map("scheduled_at")
  startedAt       DateTime?               @map("started_at")
  endedAt         DateTime?               @map("ended_at")
  status          ScheduledSessionStatus  @default(SCHEDULED)

  // Recording
  recordingPath        String?            @map("recording_path")
  durationSeconds      Int?               @map("duration_seconds")
  egressId             String?            @map("egress_id")
  beaconRecordingPath  String?            @map("beacon_recording_path")
  beaconEgressId       String?            @map("beacon_egress_id")

  // Timestamps
  createdAt       DateTime                @default(now()) @map("created_at")
  updatedAt       DateTime                @updatedAt @map("updated_at")

  // Relations
  invites         SessionInvite[]
  participants    SessionParticipant[]
  listeningSessions ListeningSession[]

  @@index([providerId])
  @@index([status])
  @@map("scheduled_sessions")
}

model SessionInvite {
  id          String            @id @default(uuid())
  code        String            @unique
  sessionId   String            @map("session_id")
  session     ScheduledSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  maxUses     Int               @default(0) @map("max_uses")  // 0 = unlimited
  usedCount   Int               @default(0) @map("used_count")
  expiresAt   DateTime?         @map("expires_at")
  canPublish  Boolean           @default(false) @map("can_publish")

  createdAt   DateTime          @default(now()) @map("created_at")

  @@index([sessionId])
  @@map("session_invites")
}

model SessionParticipant {
  id              String            @id @default(uuid())
  sessionId       String            @map("session_id")
  session         ScheduledSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  userId          String            @map("user_id")
  user            User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  joinedAt        DateTime          @default(now()) @map("joined_at")
  leftAt          DateTime?         @map("left_at")
  durationSeconds Int?              @map("duration_seconds")

  @@unique([sessionId, userId])
  @@index([userId])
  @@map("session_participants")
}
